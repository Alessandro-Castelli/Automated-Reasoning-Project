\documentclass{article}
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc} 
\usepackage{graphicx}  
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsfonts} 
\usepackage[hidelinks]{hyperref}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{multicol}


\geometry{left=1.5cm, right=1.5cm, top=2cm, bottom=2cm}

\setlength{\columnsep}{1cm} % Imposta lo spazio tra le colonne

% Definizione dello stile per MiniZinc
\lstdefinestyle{minizinc}{
    language=Python,  % Utilizziamo Python per la sintassi
    backgroundcolor=\color{white}, % Colore di sfondo
    basicstyle=\ttfamily\small,    % Font monospaziato
    keywordstyle=\color{blue}\bfseries, % Parole chiave in blu
    commentstyle=\color{green!50!black}, % Commenti in verde
    stringstyle=\color{red},        % Stringhe in rosso
    numberstyle=\tiny\color{gray},  % Stile della numerazione
    stepnumber=1,                  % Numerazione ogni riga
    numbersep=5pt,                 % Distanza della numerazione dal codice
    breaklines=true,               % Andare a capo automatico
    frame=single,                  % Cornice attorno al codice
    captionpos=b,                   % Posizione della didascalia
    frame=none
}
% Configurazione del pacchetto hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    filecolor=blue,
    urlcolor=blue
}
\begin{document}

\title{Report Automated Reasoning} 
\author{Alessandro Castelli \and (147073)} 
\date{\today}

\maketitle
\thispagestyle{empty}  
\newpage
\tableofcontents
\setcounter{page}{1}
\pagenumbering{arabic} % Numerazione in numeri arabi
\pagestyle{fancy}
\fancyhf{} % Pulisce intestazioni e piè di pagina
\fancyfoot[C]{\thepage} % Centra il numero di pagina nel piè di pagina
\renewcommand{\headrulewidth}{0pt} % Rimuove la linea orizzontale dell'intestazione

\newpage
\begin{multicols*}{2}
\section{Introduzione}
Il presente report si concentra sull'analisi delle soluzioni al problema assegnato, 
riguardante l'organizzazione di un torneo di calcio a 7. 
Il problema in questione presenta diverse sfide legate alla suddivisione ottimale dei giocatori in squadre, rispettando specifici vincoli e minimizzando le penalità assegnate alle diverse configurazioni di squadra.

\subsection{Problema: Torneo di calcio a 7}
\begin{quote}
    Consideriamo un insieme di \( n \) giocatori di calcio \( p_1, p_2, \ldots, p_n \).
    Supponiamo che n sia un multiplo di 7. 
    Ciascuno di loro può giocare come portiere (g), difensore (d), centrocampista (m), attaccante (f). 
    Ognuno di loro sceglie esattamente due di queste opzioni (dati di input).
    Il problema è quello di dividerli in k squadre dove ciascuna squadra ha esattamente un g, almeno un d, almeno un m e almeno un f. Un ruolo unico viene assegnato a ciascuno di loro tra uno dei due dichiarati in input.
    Se una squadra ha esattamente 3 d, 2 m e 1 f, la sua penalità è 0. Se una squadra ha esattamente 2 d, 3 m e 1 f, la sua penalità è 0. Decidi (sei libero di assegnare valori) penalità non nulle per tutte le altre conformazioni.
    Trova una soluzione che minimizzi la somma delle penalità.
    Viene fornito anche un elenco di vincoli del tipo differentteam (\( p_i, p_j\)) 
    in input che costringono \(p_i\) e \(p_j\) a essere in squadre diverse. 
\end{quote}
Il problema affrontato è un \texttt{Constraint Optimization Problem} \textbf{\texttt{(COP)}}. 
Per risolverlo, sono stati sviluppati due programmi che impiegano due tecniche di programmazione distinte: \textbf{programmazione per vincoli con MiniZinc} e \textbf{Answer Set Programming utilizzando il solver Clingo}.
\\
Entrambi gli approcci sono stati selezionati per la loro efficacia nella gestione di problemi complessi e vincolati, sebbene differiscano nelle metodologie e negli strumenti adottati per ottenere la soluzione ottimale. 
\\
Nelle sezioni seguenti, verranno fornite descrizioni approfondite di entrambi gli approcci.
Inoltre, sarà presentata un'analisi dei risultati ottenuti da ciascun metodo. 

\section{Modellazione del problema}
Prima di iniziare la fase di programmazione, ho proceduto con lo studio e l'analisi del testo. Di seguito riporto alcune assunzioni che ho fatto:
\\
Le assunzioni fatte per la risoluzione del problema sono le seguenti:

\begin{itemize}
    \item I giocatori iniziali sono \( n \) e \( n \) deve sempre essere un numero multiplo di 7.
    \item Per le \( k \) squadre, non è necessario che ogni squadra abbia esattamente 7 giocatori; ogni squadra può avere un minimo di 4 giocatori (uno per ogni ruolo) e un massimo di \( n \).
    \item Il numero di squadre \( k \) deve essere scelto in modo tale da avere senso rispetto al numero totale di giocatori; altrimenti, il problema non è soddisfacibile.
    \item Ogni giocatore può ricoprire solo uno dei due ruoli selezionati per la sua assegnazione finale.
    \item Ogni squadra deve avere esattamente un portiere (g), almeno un difensore (d), almeno un centrocampista (m) e almeno un attaccante (f).
    \item È previsto un sistema di penalità per configurazioni di ruolo specifiche, dove determinate combinazioni non comportano penalità.
    \item Sono forniti vincoli che richiedono che alcune coppie di giocatori siano assegnati a squadre diverse.
\end{itemize}

\section{Soluzione Minizinc}
Nella seguente sezione troverai la spiegazione del modello Minzinc che è stato costruito per risolvere il problema.

\subsection{Input}

\begin{lstlisting}[style=minizinc, caption={Esempio di input MiniZinc}, label={lst:minizinc_example}]
n = 7;
k = 2;
roles = [
    {m, f}, % Ruolo giocatore 1
    {d, m}, % Ruolo giocatore 2
    {m, d},
    {d, g},
    {d, g},
    {g, d},
    {d, g}  % Ruolo giocatore n
];
num_pairs = 1;
player1 = [5];
player2 = [1];
\end{lstlisting}
Nel codice mostrato in \href{#lst:minizinc_example}{Listing \ref{lst:minizinc_example}}, è possibile vedere quali sono i dati che il modello vuole in input. È necessario inserire:
\begin{itemize}
    \item Il numero di giocatori \texttt{n}
    \item Il numero di squadre \texttt{k}
    \item Il ruolo dei giocatori \texttt{roles}
    \item Il numero di coppie di giocatori che non possono giocare nella stessa squadra \texttt{num\_pairs}
    \item \texttt{player1} e \texttt{player2} contengono i giocatori che non possono giocare insieme. I giocatori contenuti in posizioni uguali negli array non possono giocare nella stessa squadra. Per esempio, in {Listing\ref{lst:minizinc_example}}, il giocatore 5 e il giocatore 1 devono giocare in squadre diverse.
\end{itemize}

\subsection{I vincoli Minizinc}
Per la corretta modellazione del problema, sono stati definiti diversi \texttt{vincoli} che regolano l'assegnazione dei ruoli ai giocatori all'interno delle squadre, garantendo così il rispetto delle regole del gioco e l'equilibrio tra i team. Di seguito, vengono descritti i principali vincoli implementati:


\begin{lstlisting}[style=minizinc, caption={Vincolo 1 Minizinc}, label={lst:minizinc_vincolo}]
constraint
forall(t in 1..k) (
    % Ogni squadra deve avere esattamente un portiere
    sum([assigned_role[j] == g | j in 1..n where team[j] == t]) == 1 /\
    % Almeno un difensore
    sum([assigned_role[j] == d | j in 1..n where team[j] == t]) >= 1 /\
    % Almeno un centrocampista
    sum([assigned_role[j] == m | j in 1..n where team[j] == t]) >= 1 /\
    % Almeno un attaccante
    sum([assigned_role[j] == f | j in 1..n where team[j] == t]) >= 1
);
\end{lstlisting}

\begin{lstlisting}[style=minizinc, caption={Vincolo 2 Minizinc}, label={lst:minizinc_vincolo2}]
% Ogni giocatore deve essere assegnato a uno dei suoi ruoli scelti
constraint
    forall(i in 1..n) (
        assigned_role[i] in roles[i]
    );
\end{lstlisting}

\begin{lstlisting}[style=minizinc, caption={Vincolo 3 Minizinc}, label={lst:minizinc_vincolo3}]
    constraint
    forall(i in 1..num_pairs) (
        team[player1[i]] != team[player2[i]]
    );
\end{lstlisting}
Il \textbf{Vincolo 1} assicura che ogni squadra abbia esattamente un portiere e almeno un giocatore per ciascuna delle altre posizioni chiave: difensore, centrocampista e attaccante. Questo garantisce che ogni team abbia una struttura bilanciata e conforme alle regole del gioco.
\\
Il \textbf{Vincolo 2} specifica che ogni giocatore deve essere assegnato a uno dei ruoli per cui è stato selezionato, assicurando che le preferenze e le competenze dei giocatori siano rispettate nella formazione delle squadre.
\\
Infine, il \textbf{Vincolo 3} stabilisce che due giocatori predefiniti non devono appartenere alla stessa squadra. Questo vincolo può essere utilizzato, ad esempio, per evitare che due giocatori incompatibili giochino insieme o per distribuire equamente i giocatori più forti tra le squadre.
\\
Questi vincoli sono fondamentali per garantire una formazione delle squadre che sia equilibrata e conforme alle regole stabilite, facilitando così un'esperienza di gioco equa e competitiva.

\subsection{Penalità}
Nella competizione è stato previsto l'assegnamento di penalità alle squadre che non rispettano la configurazione richiesta del numero di giocatori nei vari ruoli. Questo criterio garantisce una formazione equilibrata e corretta per ciascuna squadra. 
\\
In particolare, le formazioni senza penalità (penalità 0) devono rispettare esattamente uno dei seguenti schemi:
\begin{itemize}
    \item 3 difensori, 2 centrocampisti, 1 attaccante, 1 portiere
    \item 2 difensori, 3 centrocampisti, 1 attaccante, 1 portiere
\end{itemize} 
Qualsiasi altra combinazione di giocatori comporta una penalità (penalità 1).
Di seguito è riportato il codice MiniZinc utilizzato per calcolare le penalità per ogni squadra. L'array \texttt{penalties} contiene le penalità assegnate a ciascuna squadra in base alla conformità con i requisiti sopra descritti.
\begin{lstlisting}[style=minizinc, caption={Penalità}, label={lst:penalita}]
array[1..k] of var 0..1: penalties;
constraint
    forall(t in 1..k) (
        let {
            var int: d_count = sum([assigned_role[j] == d | j in 1..n where team[j] == t]),
            var int: m_count = sum([assigned_role[j] == m | j in 1..n where team[j] == t]),
            var int: f_count = sum([assigned_role[j] == f | j in 1..n where team[j] == t])
        } in
        if d_count == 3 /\ m_count == 2 /\ f_count == 1 then
            penalties[t] = 0
        elseif d_count == 2 /\ m_count == 3 /\ f_count == 1 then
            penalties[t] = 0
        else
            penalties[t] = 1
        endif
    );
\end{lstlisting}

\subsection{Obiettivo e risultati}
L'obiettivo del programma è trovare la soluzione migliore che minimizzi le penalità (Listing \ref{lst:obb})

\begin{lstlisting}[style=minizinc, caption={Obiettivo}, label={lst:obb}]
    solve minimize total_penalty;
\end{lstlisting}
\end{multicols*}

Per misurare le perfromance del modello ho creato una batteria di test: 10 facili, 10 di difficoltà media e 10 difficili.


\end{document}
