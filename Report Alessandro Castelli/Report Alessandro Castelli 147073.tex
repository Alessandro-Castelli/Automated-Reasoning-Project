\documentclass{article}
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc} 
\usepackage{graphicx}  
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsfonts} 
\usepackage[hidelinks]{hyperref}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{multicol}
\usepackage{float}
\usepackage{caption}


\geometry{left=1.5cm, right=1.5cm, top=2cm, bottom=2cm}

\setlength{\columnsep}{1cm} % Imposta lo spazio tra le colonne

% Definizione dello stile per MiniZinc
\lstdefinestyle{minizinc}{
    language=Python,  % Utilizziamo Python per la sintassi
    backgroundcolor=\color{white}, % Colore di sfondo
    basicstyle=\ttfamily\small,    % Font monospaziato
    keywordstyle=\color{blue}\bfseries, % Parole chiave in blu
    commentstyle=\color{green!50!black}, % Commenti in verde
    stringstyle=\color{red},        % Stringhe in rosso
    numberstyle=\tiny\color{gray},  % Stile della numerazione
    stepnumber=1,                  % Numerazione ogni riga
    numbersep=5pt,                 % Distanza della numerazione dal codice
    breaklines=true,               % Andare a capo automatico
    frame=single,                  % Cornice attorno al codice
    captionpos=b,                   % Posizione della didascalia
    frame=none
}
% Configurazione del pacchetto hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    filecolor=blue,
    urlcolor=blue
}
\begin{document}
% chktex-file 44

\title{Report Automated Reasoning} 
\author{Alessandro Castelli \and (147073)} 
\date{\today}

\maketitle
\thispagestyle{empty}  
\newpage
\captionsetup[table]{skip=10pt} 
\tableofcontents
\setcounter{page}{1}
\pagenumbering{arabic} % Numerazione in numeri arabi
\pagestyle{fancy}
\fancyhf{} % Pulisce intestazioni e piè di pagina
\fancyfoot[C]{\thepage} % Centra il numero di pagina nel piè di pagina
\renewcommand{\headrulewidth}{0pt} % Rimuove la linea orizzontale dell'intestazione

\newpage
\begin{multicols*}{2}
\section{Introduzione}
Il presente report si concentra sull'analisi delle soluzioni al problema assegnato, 
riguardante l'organizzazione di un torneo di calcio a 7. 
Il problema in questione presenta diverse sfide legate alla suddivisione ottimale dei giocatori in squadre, rispettando specifici vincoli e minimizzando le penalità assegnate alle diverse configurazioni di squadra.

\subsection{Problema: Torneo di calcio a 7}
\begin{quote}
    Consideriamo un insieme di \( n \) giocatori di calcio \( p_1, p_2, \ldots, p_n \).
    Supponiamo che n sia un multiplo di 7. 
    Ciascuno di loro può giocare come portiere (g), difensore (d), centrocampista (m), attaccante (f). 
    Ognuno di loro sceglie esattamente due di queste opzioni (dati di input).
    Il problema è quello di dividerli in k squadre dove ciascuna squadra ha esattamente un g, almeno un d, almeno un m e almeno un f. Un ruolo unico viene assegnato a ciascuno di loro tra uno dei due dichiarati in input.
    Se una squadra ha esattamente 3 d, 2 m e 1 f, la sua penalità è 0. Se una squadra ha esattamente 2 d, 3 m e 1 f, la sua penalità è 0. Decidi (sei libero di assegnare valori) penalità non nulle per tutte le altre conformazioni.
    Trova una soluzione che minimizzi la somma delle penalità.
    Viene fornito anche un elenco di vincoli del tipo differentteam (\( p_i, p_j\)) 
    in input che costringono \(p_i\) e \(p_j\) a essere in squadre diverse. 
\end{quote}
Il problema affrontato è un \texttt{Constraint Optimization Problem} \textbf{\texttt{(COP)}}. 
Per risolverlo, sono stati sviluppati due programmi che impiegano due tecniche di programmazione distinte: \textbf{programmazione per vincoli con MiniZinc} e \textbf{Answer Set Programming utilizzando il solver Clingo}.
\\
Entrambi gli approcci sono stati selezionati per la loro efficacia nella gestione di problemi complessi e vincolati, sebbene differiscano nelle metodologie e negli strumenti adottati per ottenere la soluzione ottimale. 
\\
Nelle sezioni seguenti, verranno fornite descrizioni approfondite di entrambi gli approcci.
Inoltre, sarà presentata un'analisi dei risultati ottenuti da ciascun metodo. 

\section{Modellazione del problema}
Prima di iniziare la fase di programmazione, ho proceduto con lo studio e l'analisi del testo. Di seguito riporto alcune assunzioni che ho fatto:
\\
Le assunzioni fatte per la risoluzione del problema sono le seguenti:

\begin{itemize}
    \item I giocatori iniziali sono \( n \) e \( n \) deve sempre essere un numero multiplo di 7.
    \item Per le \( k \) squadre, non è necessario che ogni squadra abbia esattamente 7 giocatori; ogni squadra può avere un minimo di 4 giocatori (uno per ogni ruolo) e un massimo di \( n \).
    \item Il numero di squadre \( k \) deve essere scelto in modo tale da avere senso rispetto al numero totale di giocatori; altrimenti, il problema non è soddisfacibile.
    \item Ogni giocatore può ricoprire solo uno dei due ruoli selezionati per la sua assegnazione finale.
    \item Ogni squadra deve avere esattamente un portiere (g), almeno un difensore (d), almeno un centrocampista (m) e almeno un attaccante (f).
    \item È previsto un sistema di penalità per configurazioni di ruolo specifiche, dove determinate combinazioni non comportano penalità.
    \item Sono forniti vincoli che richiedono che alcune coppie di giocatori siano assegnati a squadre diverse.
\end{itemize}

\section{Soluzione Minizinc}
Nella seguente sezione troverai la spiegazione del modello Minzinc che è stato costruito per risolvere il problema.

\subsection{Input}

\begin{lstlisting}[style=minizinc, caption={Esempio di input MiniZinc}, label={lst:minizinc_example}]
n = 7;
k = 2;
roles = [
    {m, f}, % Ruolo giocatore 1
    {d, m}, % Ruolo giocatore 2
    {m, d},
    {d, g},
    {d, g},
    {g, d},
    {d, g}  % Ruolo giocatore n
];
num_pairs = 1;
player1 = [5];
player2 = [1];
\end{lstlisting}
Nel codice mostrato in \href{#lst:minizinc_example}{Listing \ref{lst:minizinc_example}}, è possibile vedere quali sono i dati che il modello vuole in input. È necessario inserire:
\begin{itemize}
    \item Il numero di giocatori \texttt{n}
    \item Il numero di squadre \texttt{k}
    \item Il ruolo dei giocatori \texttt{roles}
    \item Il numero di coppie di giocatori che non possono giocare nella stessa squadra \texttt{num\_pairs}
    \item \texttt{player1} e \texttt{player2} contengono i giocatori che non possono giocare insieme. I giocatori contenuti in posizioni uguali negli array non possono giocare nella stessa squadra. Per esempio, in {Listing\ref{lst:minizinc_example}}, il giocatore 5 e il giocatore 1 devono giocare in squadre diverse.
\end{itemize}

\subsection{I vincoli Minizinc}
Per la corretta modellazione del problema, sono stati definiti diversi \texttt{vincoli} che regolano l'assegnazione dei ruoli ai giocatori all'interno delle squadre, garantendo così il rispetto delle regole del gioco e l'equilibrio tra i team. Di seguito, vengono descritti i principali vincoli implementati:


\begin{lstlisting}[style=minizinc, caption={Vincolo 1 Minizinc}, label={lst:minizinc_vincolo}]
constraint
forall(t in 1..k) (
    % Ogni squadra deve avere esattamente un portiere
    sum([assigned_role[j] == g | j in 1..n where team[j] == t]) == 1 /\
    % Almeno un difensore
    sum([assigned_role[j] == d | j in 1..n where team[j] == t]) >= 1 /\
    % Almeno un centrocampista
    sum([assigned_role[j] == m | j in 1..n where team[j] == t]) >= 1 /\
    % Almeno un attaccante
    sum([assigned_role[j] == f | j in 1..n where team[j] == t]) >= 1
);
\end{lstlisting}

\begin{lstlisting}[style=minizinc, caption={Vincolo 2 Minizinc}, label={lst:minizinc_vincolo2}]
% Ogni giocatore deve essere assegnato a uno dei suoi ruoli scelti
constraint
    forall(i in 1..n) (
        assigned_role[i] in roles[i]
    );
\end{lstlisting}

\begin{lstlisting}[style=minizinc, caption={Vincolo 3 Minizinc}, label={lst:minizinc_vincolo3}]
    constraint
    forall(i in 1..num_pairs) (
        team[player1[i]] != team[player2[i]]
    );
\end{lstlisting}
Il \textbf{Vincolo 1} assicura che ogni squadra abbia esattamente un portiere e almeno un giocatore per ciascuna delle altre posizioni chiave: difensore, centrocampista e attaccante. Questo garantisce che ogni team abbia una struttura bilanciata e conforme alle regole del gioco.
\\
Il \textbf{Vincolo 2} specifica che ogni giocatore deve essere assegnato a uno dei ruoli per cui è stato selezionato, assicurando che le preferenze e le competenze dei giocatori siano rispettate nella formazione delle squadre.
\\
Infine, il \textbf{Vincolo 3} stabilisce che due giocatori predefiniti non devono appartenere alla stessa squadra. Questo vincolo può essere utilizzato, ad esempio, per evitare che due giocatori incompatibili giochino insieme o per distribuire equamente i giocatori più forti tra le squadre.
\\
Questi vincoli sono fondamentali per garantire una formazione delle squadre che sia equilibrata e conforme alle regole stabilite, facilitando così un'esperienza di gioco equa e competitiva.

\subsection{Penalità}
Nella competizione è stato previsto l'assegnamento di penalità alle squadre che non rispettano la configurazione richiesta del numero di giocatori nei vari ruoli. Questo criterio garantisce una formazione equilibrata e corretta per ciascuna squadra. 
\\
In particolare, le formazioni senza penalità (penalità 0) devono rispettare esattamente uno dei seguenti schemi:
\begin{itemize}
    \item 3 difensori, 2 centrocampisti, 1 attaccante, 1 portiere
    \item 2 difensori, 3 centrocampisti, 1 attaccante, 1 portiere
\end{itemize} 
Qualsiasi altra combinazione di giocatori comporta una penalità (penalità 1).
Di seguito è riportato il codice MiniZinc utilizzato per calcolare le penalità per ogni squadra. L'array \texttt{penalties} contiene le penalità assegnate a ciascuna squadra in base alla conformità con i requisiti sopra descritti.
\begin{lstlisting}[style=minizinc, caption={Penalità}, label={lst:penalita}]
array[1..k] of var 0..1: penalties;
constraint
    forall(t in 1..k) (
        let {
            var int: d_count = sum([assigned_role[j] == d | j in 1..n where team[j] == t]),
            var int: m_count = sum([assigned_role[j] == m | j in 1..n where team[j] == t]),
            var int: f_count = sum([assigned_role[j] == f | j in 1..n where team[j] == t])
        } in
        if d_count == 3 /\ m_count == 2 /\ f_count == 1 then
            penalties[t] = 0
        elseif d_count == 2 /\ m_count == 3 /\ f_count == 1 then
            penalties[t] = 0
        else
            penalties[t] = 1
        endif
    );
\end{lstlisting}

\subsection{Obiettivo e risultati}

L'obiettivo del programma è trovare la soluzione che minimizzi le penalità (vedi Listing~\ref{lst:obb}).

\begin{lstlisting}[style=minizinc, caption={Obiettivo del problema}, label={lst:obb}]
solve minimize total_penalty;
\end{lstlisting}
Per valutare le performance del modello implementato, 
sono stati creati tre gruppi di test con livelli di difficoltà differenti: facile, medio e difficile. 
Ogni gruppo è composto da 10 istanze, ciascuna delle quali è stata generata in modo casuale, includendo variabili come il numero di giocatori, il numero di squadre, i ruoli dei giocatori e l'assegnazione dei giocatori a squadre diverse.
I risultati dei test sono stati registrati e confrontati per analizzare l'efficacia dell'algoritmo utilizzato. 
I file di input e output relativi sono inclusi nel progetto e disponibili per consultazione.

\subsection{Struttura dei Test}

\begin{itemize}
    \item \textbf{Facile}: 10 istanze con parametri relativamente semplici.
    \item \textbf{Medio}: 10 istanze con parametri di difficoltà intermedia.
    \item \textbf{Difficile}: 10 istanze con parametri complessi.
\end{itemize}

\subsection{Metodologia}

Per ciascuna istanza sono stati utilizzati due solver: Gecode e Chuffed. Il tempo massimo di esecuzione (timeout) per ogni istanza è stato impostato a 5 minuti. Se un solver non riesce a trovare una soluzione entro questo tempo, viene segnato come \textit{TIMEOUT}.

\subsection{Risultati}
I risultati ottenuti sono riportati nella Tabella~\ref{tab:minizinc}, che mostra il tempo di esecuzione in secondi per ogni istanza risolta dai solver Gecode e Chuffed.
\\
Come è possibile vedere dai riusltati il sover Chuffed giugnge a conclusione molto più velocemnete del solver Gecode.
\\
\texttt{TIMEOUT} vuol dire che ha superato la soglia massima di tempo che è stata impostata a 5 minuti.

\subsection{Analisi dei Risultati}
Come si può osservare dalla Tabella~\ref{tab:minizinc}, il solver Chuffed riesce a concludere i calcoli in tempi significativamente più brevi rispetto al solver Gecode in tutte le istanze. In particolare:

\begin{itemize}
    \item \textbf{Istanze Facili}: Entrambi i solver completano tutte le istanze entro il tempo limite, ma Chuffed risolve le istanze con tempi generalmente inferiori rispetto a Gecode.
    \item \textbf{Istanze Medie}: Gecode fallisce (\textit{TIMEOUT}) in molte delle istanze, mentre Chuffed riesce a completare tutte le istanze entro il tempo limite.
    \item \textbf{Istanze Difficili}: Gecode non riesce a completare la maggior parte delle istanze entro il tempo limite, mentre Chuffed riesce a risolvere alcune istanze ma fallisce (\textit{TIMEOUT}) nelle più complesse.
\end{itemize}
Si può osservare che, talvolta, istanze simili in \texttt{n} e \texttt{k} presentano tempi di esecuzione differenti. Questo avviene perché variano i ruoli dei giocatori e le assegnazioni dei giocatori a squadre diverse.

\subsection{Conclusioni}
L'analisi dei tempi di esecuzione dimostra che il solver Chuffed è significativamente più efficiente rispetto a Gecode, specialmente in situazioni di maggiore complessità. Questo suggerisce che Chuffed potrebbe essere una scelta più appropriata per applicazioni che richiedono la risoluzione di problemi complessi in tempi brevi.

\begin{table}[H]
    \centering
    \caption{Performance Minizinc}\label{tab:minizinc}
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Livello} & \textbf{n} & \textbf{k} & \textbf{Gecode (s)} & \textbf{Chuffed (s)} \\
        \hline
        Facile 1 & 7 & 2 & 0.59 & 0.16 \\
        Facile 2 & 7 & 1 & 0.18 & 0.13 \\
        Facile 3 & 7 & 2 & 0.28 & 0.17 \\
        Facile 4 & 7 & 2 & 0.23 & 0.18 \\
        Facile 5 & 7 & 1 & 0.14 & 0.13 \\
        Facile 6 & 7 & 2 & 0.31 & 0.18 \\
        Facile 7 & 7 & 1 & 0.16 & 0.13 \\
        Facile 8 & 7 & 2 & 0.17 & 0.17 \\
        Facile 9 & 7 & 2 & 0.47 & 0.17 \\
        Facile 10 & 7 & 2 & 0.18 & 0.19 \\
        \hline
        Medio 1 & 14 & 3 & TIMEOUT & 1.77 \\
        Medio 2 & 14 & 3 & TIMEOUT & 3.12 \\
        Medio 3 & 21 & 2 & 15.22 & 0.82 \\
        Medio 4 & 14 & 3 & TIMEOUT & 0.27 \\
        Medio 5 & 21 & 3 & 2.15 & 0.34 \\
        Medio 6 & 21 & 3 & 23.8 & 0.37 \\
        Medio 7 & 14 & 3 & TIMEOUT & 0.44 \\
        Medio 8 & 14 & 3 & TIMEOUT & 1.18 \\
        Medio 9 & 14 & 3 & TIMEOUT & 1.96 \\
        Medio 10 & 14 & 3 & TIMEOUT & 1.96 \\
        \hline
        Difficile 1 & 28 & 2 & 83.84 & 0.53 \\
        Difficile 2 & 28 & 3 & TIMEOUT & 15.71 \\
        Difficile 3 & 28 & 4 & TIMEOUT & 1.27 \\
        Difficile 4 & 28 & 4 & TIMEOUT & 10.02 \\
        Difficile 5 & 28 & 2 & TIMEOUT & 0.55 \\
        Difficile 6 & 28 & 4 & TIMEOUT & 30.36 \\
        Difficile 7 & 28 & 3 & TIMEOUT & TIMEOUT \\
        Difficile 8 & 35 & 3 & TIMEOUT & 13.43 \\
        Difficile 9 & 28 & 4 & TIMEOUT & TIMEOUT \\
        Difficile 10 & 28 & 4 & TIMEOUT & TIMEOUT \\
        \hline
    \end{tabular}
\end{table}
\end{multicols*}
\end{document}
